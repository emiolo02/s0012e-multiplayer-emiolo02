// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTO_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTO_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

namespace Protocol {

struct Vec3;

struct Vec4;

struct Laser;

struct Player;

struct PacketWrapper;
struct PacketWrapperBuilder;
struct PacketWrapperT;

struct ClientConnectS2C;
struct ClientConnectS2CBuilder;
struct ClientConnectS2CT;

struct GameStateS2C;
struct GameStateS2CBuilder;
struct GameStateS2CT;

struct SpawnPlayerS2C;
struct SpawnPlayerS2CBuilder;
struct SpawnPlayerS2CT;

struct DespawnPlayerS2C;
struct DespawnPlayerS2CBuilder;
struct DespawnPlayerS2CT;

struct UpdatePlayerS2C;
struct UpdatePlayerS2CBuilder;
struct UpdatePlayerS2CT;

struct TeleportPlayerS2C;
struct TeleportPlayerS2CBuilder;
struct TeleportPlayerS2CT;

struct SpawnLaserS2C;
struct SpawnLaserS2CBuilder;
struct SpawnLaserS2CT;

struct DespawnLaserS2C;
struct DespawnLaserS2CBuilder;
struct DespawnLaserS2CT;

struct CollisionS2C;
struct CollisionS2CBuilder;
struct CollisionS2CT;

struct TextS2C;
struct TextS2CBuilder;
struct TextS2CT;

struct InputC2S;
struct InputC2SBuilder;
struct InputC2ST;

struct TextC2S;
struct TextC2SBuilder;
struct TextC2ST;

enum PacketType : uint8_t {
  PacketType_NONE = 0,
  PacketType_InputC2S = 1,
  PacketType_TextC2S = 2,
  PacketType_ClientConnectS2C = 3,
  PacketType_GameStateS2C = 4,
  PacketType_SpawnPlayerS2C = 5,
  PacketType_DespawnPlayerS2C = 6,
  PacketType_UpdatePlayerS2C = 7,
  PacketType_TeleportPlayerS2C = 8,
  PacketType_SpawnLaserS2C = 9,
  PacketType_DespawnLaserS2C = 10,
  PacketType_CollisionS2C = 11,
  PacketType_TextS2C = 12,
  PacketType_MIN = PacketType_NONE,
  PacketType_MAX = PacketType_TextS2C
};

inline const PacketType (&EnumValuesPacketType())[13] {
  static const PacketType values[] = {
    PacketType_NONE,
    PacketType_InputC2S,
    PacketType_TextC2S,
    PacketType_ClientConnectS2C,
    PacketType_GameStateS2C,
    PacketType_SpawnPlayerS2C,
    PacketType_DespawnPlayerS2C,
    PacketType_UpdatePlayerS2C,
    PacketType_TeleportPlayerS2C,
    PacketType_SpawnLaserS2C,
    PacketType_DespawnLaserS2C,
    PacketType_CollisionS2C,
    PacketType_TextS2C
  };
  return values;
}

inline const char * const *EnumNamesPacketType() {
  static const char * const names[14] = {
    "NONE",
    "InputC2S",
    "TextC2S",
    "ClientConnectS2C",
    "GameStateS2C",
    "SpawnPlayerS2C",
    "DespawnPlayerS2C",
    "UpdatePlayerS2C",
    "TeleportPlayerS2C",
    "SpawnLaserS2C",
    "DespawnLaserS2C",
    "CollisionS2C",
    "TextS2C",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacketType(PacketType e) {
  if (::flatbuffers::IsOutRange(e, PacketType_NONE, PacketType_TextS2C)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPacketType()[index];
}

template<typename T> struct PacketTypeTraits {
  static const PacketType enum_value = PacketType_NONE;
};

template<> struct PacketTypeTraits<Protocol::InputC2S> {
  static const PacketType enum_value = PacketType_InputC2S;
};

template<> struct PacketTypeTraits<Protocol::TextC2S> {
  static const PacketType enum_value = PacketType_TextC2S;
};

template<> struct PacketTypeTraits<Protocol::ClientConnectS2C> {
  static const PacketType enum_value = PacketType_ClientConnectS2C;
};

template<> struct PacketTypeTraits<Protocol::GameStateS2C> {
  static const PacketType enum_value = PacketType_GameStateS2C;
};

template<> struct PacketTypeTraits<Protocol::SpawnPlayerS2C> {
  static const PacketType enum_value = PacketType_SpawnPlayerS2C;
};

template<> struct PacketTypeTraits<Protocol::DespawnPlayerS2C> {
  static const PacketType enum_value = PacketType_DespawnPlayerS2C;
};

template<> struct PacketTypeTraits<Protocol::UpdatePlayerS2C> {
  static const PacketType enum_value = PacketType_UpdatePlayerS2C;
};

template<> struct PacketTypeTraits<Protocol::TeleportPlayerS2C> {
  static const PacketType enum_value = PacketType_TeleportPlayerS2C;
};

template<> struct PacketTypeTraits<Protocol::SpawnLaserS2C> {
  static const PacketType enum_value = PacketType_SpawnLaserS2C;
};

template<> struct PacketTypeTraits<Protocol::DespawnLaserS2C> {
  static const PacketType enum_value = PacketType_DespawnLaserS2C;
};

template<> struct PacketTypeTraits<Protocol::CollisionS2C> {
  static const PacketType enum_value = PacketType_CollisionS2C;
};

template<> struct PacketTypeTraits<Protocol::TextS2C> {
  static const PacketType enum_value = PacketType_TextS2C;
};

template<typename T> struct PacketTypeUnionTraits {
  static const PacketType enum_value = PacketType_NONE;
};

template<> struct PacketTypeUnionTraits<Protocol::InputC2ST> {
  static const PacketType enum_value = PacketType_InputC2S;
};

template<> struct PacketTypeUnionTraits<Protocol::TextC2ST> {
  static const PacketType enum_value = PacketType_TextC2S;
};

template<> struct PacketTypeUnionTraits<Protocol::ClientConnectS2CT> {
  static const PacketType enum_value = PacketType_ClientConnectS2C;
};

template<> struct PacketTypeUnionTraits<Protocol::GameStateS2CT> {
  static const PacketType enum_value = PacketType_GameStateS2C;
};

template<> struct PacketTypeUnionTraits<Protocol::SpawnPlayerS2CT> {
  static const PacketType enum_value = PacketType_SpawnPlayerS2C;
};

template<> struct PacketTypeUnionTraits<Protocol::DespawnPlayerS2CT> {
  static const PacketType enum_value = PacketType_DespawnPlayerS2C;
};

template<> struct PacketTypeUnionTraits<Protocol::UpdatePlayerS2CT> {
  static const PacketType enum_value = PacketType_UpdatePlayerS2C;
};

template<> struct PacketTypeUnionTraits<Protocol::TeleportPlayerS2CT> {
  static const PacketType enum_value = PacketType_TeleportPlayerS2C;
};

template<> struct PacketTypeUnionTraits<Protocol::SpawnLaserS2CT> {
  static const PacketType enum_value = PacketType_SpawnLaserS2C;
};

template<> struct PacketTypeUnionTraits<Protocol::DespawnLaserS2CT> {
  static const PacketType enum_value = PacketType_DespawnLaserS2C;
};

template<> struct PacketTypeUnionTraits<Protocol::CollisionS2CT> {
  static const PacketType enum_value = PacketType_CollisionS2C;
};

template<> struct PacketTypeUnionTraits<Protocol::TextS2CT> {
  static const PacketType enum_value = PacketType_TextS2C;
};

struct PacketTypeUnion {
  PacketType type;
  void *value;

  PacketTypeUnion() : type(PacketType_NONE), value(nullptr) {}
  PacketTypeUnion(PacketTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(PacketType_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PacketTypeUnion(const PacketTypeUnion &);
  PacketTypeUnion &operator=(const PacketTypeUnion &u)
    { PacketTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PacketTypeUnion &operator=(PacketTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PacketTypeUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = PacketTypeUnionTraits<RT>::enum_value;
    if (type != PacketType_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, PacketType type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Protocol::InputC2ST *AsInputC2S() {
    return type == PacketType_InputC2S ?
      reinterpret_cast<Protocol::InputC2ST *>(value) : nullptr;
  }
  const Protocol::InputC2ST *AsInputC2S() const {
    return type == PacketType_InputC2S ?
      reinterpret_cast<const Protocol::InputC2ST *>(value) : nullptr;
  }
  Protocol::TextC2ST *AsTextC2S() {
    return type == PacketType_TextC2S ?
      reinterpret_cast<Protocol::TextC2ST *>(value) : nullptr;
  }
  const Protocol::TextC2ST *AsTextC2S() const {
    return type == PacketType_TextC2S ?
      reinterpret_cast<const Protocol::TextC2ST *>(value) : nullptr;
  }
  Protocol::ClientConnectS2CT *AsClientConnectS2C() {
    return type == PacketType_ClientConnectS2C ?
      reinterpret_cast<Protocol::ClientConnectS2CT *>(value) : nullptr;
  }
  const Protocol::ClientConnectS2CT *AsClientConnectS2C() const {
    return type == PacketType_ClientConnectS2C ?
      reinterpret_cast<const Protocol::ClientConnectS2CT *>(value) : nullptr;
  }
  Protocol::GameStateS2CT *AsGameStateS2C() {
    return type == PacketType_GameStateS2C ?
      reinterpret_cast<Protocol::GameStateS2CT *>(value) : nullptr;
  }
  const Protocol::GameStateS2CT *AsGameStateS2C() const {
    return type == PacketType_GameStateS2C ?
      reinterpret_cast<const Protocol::GameStateS2CT *>(value) : nullptr;
  }
  Protocol::SpawnPlayerS2CT *AsSpawnPlayerS2C() {
    return type == PacketType_SpawnPlayerS2C ?
      reinterpret_cast<Protocol::SpawnPlayerS2CT *>(value) : nullptr;
  }
  const Protocol::SpawnPlayerS2CT *AsSpawnPlayerS2C() const {
    return type == PacketType_SpawnPlayerS2C ?
      reinterpret_cast<const Protocol::SpawnPlayerS2CT *>(value) : nullptr;
  }
  Protocol::DespawnPlayerS2CT *AsDespawnPlayerS2C() {
    return type == PacketType_DespawnPlayerS2C ?
      reinterpret_cast<Protocol::DespawnPlayerS2CT *>(value) : nullptr;
  }
  const Protocol::DespawnPlayerS2CT *AsDespawnPlayerS2C() const {
    return type == PacketType_DespawnPlayerS2C ?
      reinterpret_cast<const Protocol::DespawnPlayerS2CT *>(value) : nullptr;
  }
  Protocol::UpdatePlayerS2CT *AsUpdatePlayerS2C() {
    return type == PacketType_UpdatePlayerS2C ?
      reinterpret_cast<Protocol::UpdatePlayerS2CT *>(value) : nullptr;
  }
  const Protocol::UpdatePlayerS2CT *AsUpdatePlayerS2C() const {
    return type == PacketType_UpdatePlayerS2C ?
      reinterpret_cast<const Protocol::UpdatePlayerS2CT *>(value) : nullptr;
  }
  Protocol::TeleportPlayerS2CT *AsTeleportPlayerS2C() {
    return type == PacketType_TeleportPlayerS2C ?
      reinterpret_cast<Protocol::TeleportPlayerS2CT *>(value) : nullptr;
  }
  const Protocol::TeleportPlayerS2CT *AsTeleportPlayerS2C() const {
    return type == PacketType_TeleportPlayerS2C ?
      reinterpret_cast<const Protocol::TeleportPlayerS2CT *>(value) : nullptr;
  }
  Protocol::SpawnLaserS2CT *AsSpawnLaserS2C() {
    return type == PacketType_SpawnLaserS2C ?
      reinterpret_cast<Protocol::SpawnLaserS2CT *>(value) : nullptr;
  }
  const Protocol::SpawnLaserS2CT *AsSpawnLaserS2C() const {
    return type == PacketType_SpawnLaserS2C ?
      reinterpret_cast<const Protocol::SpawnLaserS2CT *>(value) : nullptr;
  }
  Protocol::DespawnLaserS2CT *AsDespawnLaserS2C() {
    return type == PacketType_DespawnLaserS2C ?
      reinterpret_cast<Protocol::DespawnLaserS2CT *>(value) : nullptr;
  }
  const Protocol::DespawnLaserS2CT *AsDespawnLaserS2C() const {
    return type == PacketType_DespawnLaserS2C ?
      reinterpret_cast<const Protocol::DespawnLaserS2CT *>(value) : nullptr;
  }
  Protocol::CollisionS2CT *AsCollisionS2C() {
    return type == PacketType_CollisionS2C ?
      reinterpret_cast<Protocol::CollisionS2CT *>(value) : nullptr;
  }
  const Protocol::CollisionS2CT *AsCollisionS2C() const {
    return type == PacketType_CollisionS2C ?
      reinterpret_cast<const Protocol::CollisionS2CT *>(value) : nullptr;
  }
  Protocol::TextS2CT *AsTextS2C() {
    return type == PacketType_TextS2C ?
      reinterpret_cast<Protocol::TextS2CT *>(value) : nullptr;
  }
  const Protocol::TextS2CT *AsTextS2C() const {
    return type == PacketType_TextS2C ?
      reinterpret_cast<const Protocol::TextS2CT *>(value) : nullptr;
  }
};

bool VerifyPacketType(::flatbuffers::Verifier &verifier, const void *obj, PacketType type);
bool VerifyPacketTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    ::flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    ::flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    ::flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    ::flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    ::flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    ::flatbuffers::WriteScalar(&z_, _z);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
  void mutate_w(float _w) {
    ::flatbuffers::WriteScalar(&w_, _w);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Laser FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t uuid_;
  int32_t padding0__;
  uint64_t start_time_;
  uint64_t end_time_;
  Protocol::Vec3 origin_;
  Protocol::Vec4 direction_;
  int32_t padding1__;

 public:
  Laser()
      : uuid_(0),
        padding0__(0),
        start_time_(0),
        end_time_(0),
        origin_(),
        direction_(),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  Laser(uint32_t _uuid, uint64_t _start_time, uint64_t _end_time, const Protocol::Vec3 &_origin, const Protocol::Vec4 &_direction)
      : uuid_(::flatbuffers::EndianScalar(_uuid)),
        padding0__(0),
        start_time_(::flatbuffers::EndianScalar(_start_time)),
        end_time_(::flatbuffers::EndianScalar(_end_time)),
        origin_(_origin),
        direction_(_direction),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  uint32_t uuid() const {
    return ::flatbuffers::EndianScalar(uuid_);
  }
  void mutate_uuid(uint32_t _uuid) {
    ::flatbuffers::WriteScalar(&uuid_, _uuid);
  }
  uint64_t start_time() const {
    return ::flatbuffers::EndianScalar(start_time_);
  }
  void mutate_start_time(uint64_t _start_time) {
    ::flatbuffers::WriteScalar(&start_time_, _start_time);
  }
  uint64_t end_time() const {
    return ::flatbuffers::EndianScalar(end_time_);
  }
  void mutate_end_time(uint64_t _end_time) {
    ::flatbuffers::WriteScalar(&end_time_, _end_time);
  }
  const Protocol::Vec3 &origin() const {
    return origin_;
  }
  Protocol::Vec3 &mutable_origin() {
    return origin_;
  }
  const Protocol::Vec4 &direction() const {
    return direction_;
  }
  Protocol::Vec4 &mutable_direction() {
    return direction_;
  }
};
FLATBUFFERS_STRUCT_END(Laser, 56);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Player FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t uuid_;
  Protocol::Vec3 position_;
  Protocol::Vec3 velocity_;
  Protocol::Vec3 acceleration_;
  Protocol::Vec4 direction_;

 public:
  Player()
      : uuid_(0),
        position_(),
        velocity_(),
        acceleration_(),
        direction_() {
  }
  Player(uint32_t _uuid, const Protocol::Vec3 &_position, const Protocol::Vec3 &_velocity, const Protocol::Vec3 &_acceleration, const Protocol::Vec4 &_direction)
      : uuid_(::flatbuffers::EndianScalar(_uuid)),
        position_(_position),
        velocity_(_velocity),
        acceleration_(_acceleration),
        direction_(_direction) {
  }
  uint32_t uuid() const {
    return ::flatbuffers::EndianScalar(uuid_);
  }
  void mutate_uuid(uint32_t _uuid) {
    ::flatbuffers::WriteScalar(&uuid_, _uuid);
  }
  const Protocol::Vec3 &position() const {
    return position_;
  }
  Protocol::Vec3 &mutable_position() {
    return position_;
  }
  const Protocol::Vec3 &velocity() const {
    return velocity_;
  }
  Protocol::Vec3 &mutable_velocity() {
    return velocity_;
  }
  const Protocol::Vec3 &acceleration() const {
    return acceleration_;
  }
  Protocol::Vec3 &mutable_acceleration() {
    return acceleration_;
  }
  const Protocol::Vec4 &direction() const {
    return direction_;
  }
  Protocol::Vec4 &mutable_direction() {
    return direction_;
  }
};
FLATBUFFERS_STRUCT_END(Player, 56);

struct PacketWrapperT : public ::flatbuffers::NativeTable {
  typedef PacketWrapper TableType;
  Protocol::PacketTypeUnion packet{};
};

struct PacketWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PacketWrapperT NativeTableType;
  typedef PacketWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKET_TYPE = 4,
    VT_PACKET = 6
  };
  Protocol::PacketType packet_type() const {
    return static_cast<Protocol::PacketType>(GetField<uint8_t>(VT_PACKET_TYPE, 0));
  }
  const void *packet() const {
    return GetPointer<const void *>(VT_PACKET);
  }
  template<typename T> const T *packet_as() const;
  const Protocol::InputC2S *packet_as_InputC2S() const {
    return packet_type() == Protocol::PacketType_InputC2S ? static_cast<const Protocol::InputC2S *>(packet()) : nullptr;
  }
  const Protocol::TextC2S *packet_as_TextC2S() const {
    return packet_type() == Protocol::PacketType_TextC2S ? static_cast<const Protocol::TextC2S *>(packet()) : nullptr;
  }
  const Protocol::ClientConnectS2C *packet_as_ClientConnectS2C() const {
    return packet_type() == Protocol::PacketType_ClientConnectS2C ? static_cast<const Protocol::ClientConnectS2C *>(packet()) : nullptr;
  }
  const Protocol::GameStateS2C *packet_as_GameStateS2C() const {
    return packet_type() == Protocol::PacketType_GameStateS2C ? static_cast<const Protocol::GameStateS2C *>(packet()) : nullptr;
  }
  const Protocol::SpawnPlayerS2C *packet_as_SpawnPlayerS2C() const {
    return packet_type() == Protocol::PacketType_SpawnPlayerS2C ? static_cast<const Protocol::SpawnPlayerS2C *>(packet()) : nullptr;
  }
  const Protocol::DespawnPlayerS2C *packet_as_DespawnPlayerS2C() const {
    return packet_type() == Protocol::PacketType_DespawnPlayerS2C ? static_cast<const Protocol::DespawnPlayerS2C *>(packet()) : nullptr;
  }
  const Protocol::UpdatePlayerS2C *packet_as_UpdatePlayerS2C() const {
    return packet_type() == Protocol::PacketType_UpdatePlayerS2C ? static_cast<const Protocol::UpdatePlayerS2C *>(packet()) : nullptr;
  }
  const Protocol::TeleportPlayerS2C *packet_as_TeleportPlayerS2C() const {
    return packet_type() == Protocol::PacketType_TeleportPlayerS2C ? static_cast<const Protocol::TeleportPlayerS2C *>(packet()) : nullptr;
  }
  const Protocol::SpawnLaserS2C *packet_as_SpawnLaserS2C() const {
    return packet_type() == Protocol::PacketType_SpawnLaserS2C ? static_cast<const Protocol::SpawnLaserS2C *>(packet()) : nullptr;
  }
  const Protocol::DespawnLaserS2C *packet_as_DespawnLaserS2C() const {
    return packet_type() == Protocol::PacketType_DespawnLaserS2C ? static_cast<const Protocol::DespawnLaserS2C *>(packet()) : nullptr;
  }
  const Protocol::CollisionS2C *packet_as_CollisionS2C() const {
    return packet_type() == Protocol::PacketType_CollisionS2C ? static_cast<const Protocol::CollisionS2C *>(packet()) : nullptr;
  }
  const Protocol::TextS2C *packet_as_TextS2C() const {
    return packet_type() == Protocol::PacketType_TextS2C ? static_cast<const Protocol::TextS2C *>(packet()) : nullptr;
  }
  void *mutable_packet() {
    return GetPointer<void *>(VT_PACKET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE, 1) &&
           VerifyOffset(verifier, VT_PACKET) &&
           VerifyPacketType(verifier, packet(), packet_type()) &&
           verifier.EndTable();
  }
  PacketWrapperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PacketWrapperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PacketWrapper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PacketWrapperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Protocol::InputC2S *PacketWrapper::packet_as<Protocol::InputC2S>() const {
  return packet_as_InputC2S();
}

template<> inline const Protocol::TextC2S *PacketWrapper::packet_as<Protocol::TextC2S>() const {
  return packet_as_TextC2S();
}

template<> inline const Protocol::ClientConnectS2C *PacketWrapper::packet_as<Protocol::ClientConnectS2C>() const {
  return packet_as_ClientConnectS2C();
}

template<> inline const Protocol::GameStateS2C *PacketWrapper::packet_as<Protocol::GameStateS2C>() const {
  return packet_as_GameStateS2C();
}

template<> inline const Protocol::SpawnPlayerS2C *PacketWrapper::packet_as<Protocol::SpawnPlayerS2C>() const {
  return packet_as_SpawnPlayerS2C();
}

template<> inline const Protocol::DespawnPlayerS2C *PacketWrapper::packet_as<Protocol::DespawnPlayerS2C>() const {
  return packet_as_DespawnPlayerS2C();
}

template<> inline const Protocol::UpdatePlayerS2C *PacketWrapper::packet_as<Protocol::UpdatePlayerS2C>() const {
  return packet_as_UpdatePlayerS2C();
}

template<> inline const Protocol::TeleportPlayerS2C *PacketWrapper::packet_as<Protocol::TeleportPlayerS2C>() const {
  return packet_as_TeleportPlayerS2C();
}

template<> inline const Protocol::SpawnLaserS2C *PacketWrapper::packet_as<Protocol::SpawnLaserS2C>() const {
  return packet_as_SpawnLaserS2C();
}

template<> inline const Protocol::DespawnLaserS2C *PacketWrapper::packet_as<Protocol::DespawnLaserS2C>() const {
  return packet_as_DespawnLaserS2C();
}

template<> inline const Protocol::CollisionS2C *PacketWrapper::packet_as<Protocol::CollisionS2C>() const {
  return packet_as_CollisionS2C();
}

template<> inline const Protocol::TextS2C *PacketWrapper::packet_as<Protocol::TextS2C>() const {
  return packet_as_TextS2C();
}

struct PacketWrapperBuilder {
  typedef PacketWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_packet_type(Protocol::PacketType packet_type) {
    fbb_.AddElement<uint8_t>(PacketWrapper::VT_PACKET_TYPE, static_cast<uint8_t>(packet_type), 0);
  }
  void add_packet(::flatbuffers::Offset<void> packet) {
    fbb_.AddOffset(PacketWrapper::VT_PACKET, packet);
  }
  explicit PacketWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PacketWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PacketWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PacketWrapper> CreatePacketWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Protocol::PacketType packet_type = Protocol::PacketType_NONE,
    ::flatbuffers::Offset<void> packet = 0) {
  PacketWrapperBuilder builder_(_fbb);
  builder_.add_packet(packet);
  builder_.add_packet_type(packet_type);
  return builder_.Finish();
}

::flatbuffers::Offset<PacketWrapper> CreatePacketWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const PacketWrapperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClientConnectS2CT : public ::flatbuffers::NativeTable {
  typedef ClientConnectS2C TableType;
  uint32_t uuid = 0;
  uint64_t time = 0;
};

struct ClientConnectS2C FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientConnectS2CT NativeTableType;
  typedef ClientConnectS2CBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4,
    VT_TIME = 6
  };
  uint32_t uuid() const {
    return GetField<uint32_t>(VT_UUID, 0);
  }
  bool mutate_uuid(uint32_t _uuid = 0) {
    return SetField<uint32_t>(VT_UUID, _uuid, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time = 0) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UUID, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIME, 8) &&
           verifier.EndTable();
  }
  ClientConnectS2CT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClientConnectS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ClientConnectS2C> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ClientConnectS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClientConnectS2CBuilder {
  typedef ClientConnectS2C Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uuid(uint32_t uuid) {
    fbb_.AddElement<uint32_t>(ClientConnectS2C::VT_UUID, uuid, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(ClientConnectS2C::VT_TIME, time, 0);
  }
  explicit ClientConnectS2CBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientConnectS2C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientConnectS2C>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientConnectS2C> CreateClientConnectS2C(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t uuid = 0,
    uint64_t time = 0) {
  ClientConnectS2CBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

::flatbuffers::Offset<ClientConnectS2C> CreateClientConnectS2C(::flatbuffers::FlatBufferBuilder &_fbb, const ClientConnectS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GameStateS2CT : public ::flatbuffers::NativeTable {
  typedef GameStateS2C TableType;
  std::vector<Protocol::Player> players{};
  std::vector<Protocol::Laser> lasers{};
};

struct GameStateS2C FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameStateS2CT NativeTableType;
  typedef GameStateS2CBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERS = 4,
    VT_LASERS = 6
  };
  const ::flatbuffers::Vector<const Protocol::Player *> *players() const {
    return GetPointer<const ::flatbuffers::Vector<const Protocol::Player *> *>(VT_PLAYERS);
  }
  ::flatbuffers::Vector<const Protocol::Player *> *mutable_players() {
    return GetPointer<::flatbuffers::Vector<const Protocol::Player *> *>(VT_PLAYERS);
  }
  const ::flatbuffers::Vector<const Protocol::Laser *> *lasers() const {
    return GetPointer<const ::flatbuffers::Vector<const Protocol::Laser *> *>(VT_LASERS);
  }
  ::flatbuffers::Vector<const Protocol::Laser *> *mutable_lasers() {
    return GetPointer<::flatbuffers::Vector<const Protocol::Laser *> *>(VT_LASERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.VerifyVector(players()) &&
           VerifyOffset(verifier, VT_LASERS) &&
           verifier.VerifyVector(lasers()) &&
           verifier.EndTable();
  }
  GameStateS2CT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GameStateS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GameStateS2C> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GameStateS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GameStateS2CBuilder {
  typedef GameStateS2C Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_players(::flatbuffers::Offset<::flatbuffers::Vector<const Protocol::Player *>> players) {
    fbb_.AddOffset(GameStateS2C::VT_PLAYERS, players);
  }
  void add_lasers(::flatbuffers::Offset<::flatbuffers::Vector<const Protocol::Laser *>> lasers) {
    fbb_.AddOffset(GameStateS2C::VT_LASERS, lasers);
  }
  explicit GameStateS2CBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameStateS2C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameStateS2C>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameStateS2C> CreateGameStateS2C(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Protocol::Player *>> players = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Protocol::Laser *>> lasers = 0) {
  GameStateS2CBuilder builder_(_fbb);
  builder_.add_lasers(lasers);
  builder_.add_players(players);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GameStateS2C> CreateGameStateS2CDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Protocol::Player> *players = nullptr,
    const std::vector<Protocol::Laser> *lasers = nullptr) {
  auto players__ = players ? _fbb.CreateVectorOfStructs<Protocol::Player>(*players) : 0;
  auto lasers__ = lasers ? _fbb.CreateVectorOfStructs<Protocol::Laser>(*lasers) : 0;
  return Protocol::CreateGameStateS2C(
      _fbb,
      players__,
      lasers__);
}

::flatbuffers::Offset<GameStateS2C> CreateGameStateS2C(::flatbuffers::FlatBufferBuilder &_fbb, const GameStateS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpawnPlayerS2CT : public ::flatbuffers::NativeTable {
  typedef SpawnPlayerS2C TableType;
  std::unique_ptr<Protocol::Player> player{};
  SpawnPlayerS2CT() = default;
  SpawnPlayerS2CT(const SpawnPlayerS2CT &o);
  SpawnPlayerS2CT(SpawnPlayerS2CT&&) FLATBUFFERS_NOEXCEPT = default;
  SpawnPlayerS2CT &operator=(SpawnPlayerS2CT o) FLATBUFFERS_NOEXCEPT;
};

struct SpawnPlayerS2C FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpawnPlayerS2CT NativeTableType;
  typedef SpawnPlayerS2CBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER = 4
  };
  const Protocol::Player *player() const {
    return GetStruct<const Protocol::Player *>(VT_PLAYER);
  }
  Protocol::Player *mutable_player() {
    return GetStruct<Protocol::Player *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Protocol::Player>(verifier, VT_PLAYER, 4) &&
           verifier.EndTable();
  }
  SpawnPlayerS2CT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpawnPlayerS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SpawnPlayerS2C> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpawnPlayerS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpawnPlayerS2CBuilder {
  typedef SpawnPlayerS2C Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player(const Protocol::Player *player) {
    fbb_.AddStruct(SpawnPlayerS2C::VT_PLAYER, player);
  }
  explicit SpawnPlayerS2CBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpawnPlayerS2C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpawnPlayerS2C>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpawnPlayerS2C> CreateSpawnPlayerS2C(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Protocol::Player *player = nullptr) {
  SpawnPlayerS2CBuilder builder_(_fbb);
  builder_.add_player(player);
  return builder_.Finish();
}

::flatbuffers::Offset<SpawnPlayerS2C> CreateSpawnPlayerS2C(::flatbuffers::FlatBufferBuilder &_fbb, const SpawnPlayerS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DespawnPlayerS2CT : public ::flatbuffers::NativeTable {
  typedef DespawnPlayerS2C TableType;
  uint32_t uuid = 0;
};

struct DespawnPlayerS2C FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DespawnPlayerS2CT NativeTableType;
  typedef DespawnPlayerS2CBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4
  };
  uint32_t uuid() const {
    return GetField<uint32_t>(VT_UUID, 0);
  }
  bool mutate_uuid(uint32_t _uuid = 0) {
    return SetField<uint32_t>(VT_UUID, _uuid, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UUID, 4) &&
           verifier.EndTable();
  }
  DespawnPlayerS2CT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DespawnPlayerS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DespawnPlayerS2C> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DespawnPlayerS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DespawnPlayerS2CBuilder {
  typedef DespawnPlayerS2C Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uuid(uint32_t uuid) {
    fbb_.AddElement<uint32_t>(DespawnPlayerS2C::VT_UUID, uuid, 0);
  }
  explicit DespawnPlayerS2CBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DespawnPlayerS2C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DespawnPlayerS2C>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DespawnPlayerS2C> CreateDespawnPlayerS2C(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t uuid = 0) {
  DespawnPlayerS2CBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

::flatbuffers::Offset<DespawnPlayerS2C> CreateDespawnPlayerS2C(::flatbuffers::FlatBufferBuilder &_fbb, const DespawnPlayerS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UpdatePlayerS2CT : public ::flatbuffers::NativeTable {
  typedef UpdatePlayerS2C TableType;
  uint64_t time = 0;
  std::unique_ptr<Protocol::Player> player{};
  UpdatePlayerS2CT() = default;
  UpdatePlayerS2CT(const UpdatePlayerS2CT &o);
  UpdatePlayerS2CT(UpdatePlayerS2CT&&) FLATBUFFERS_NOEXCEPT = default;
  UpdatePlayerS2CT &operator=(UpdatePlayerS2CT o) FLATBUFFERS_NOEXCEPT;
};

struct UpdatePlayerS2C FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdatePlayerS2CT NativeTableType;
  typedef UpdatePlayerS2CBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_PLAYER = 6
  };
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time = 0) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  const Protocol::Player *player() const {
    return GetStruct<const Protocol::Player *>(VT_PLAYER);
  }
  Protocol::Player *mutable_player() {
    return GetStruct<Protocol::Player *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME, 8) &&
           VerifyField<Protocol::Player>(verifier, VT_PLAYER, 4) &&
           verifier.EndTable();
  }
  UpdatePlayerS2CT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UpdatePlayerS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UpdatePlayerS2C> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UpdatePlayerS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UpdatePlayerS2CBuilder {
  typedef UpdatePlayerS2C Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(UpdatePlayerS2C::VT_TIME, time, 0);
  }
  void add_player(const Protocol::Player *player) {
    fbb_.AddStruct(UpdatePlayerS2C::VT_PLAYER, player);
  }
  explicit UpdatePlayerS2CBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdatePlayerS2C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdatePlayerS2C>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdatePlayerS2C> CreateUpdatePlayerS2C(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time = 0,
    const Protocol::Player *player = nullptr) {
  UpdatePlayerS2CBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_player(player);
  return builder_.Finish();
}

::flatbuffers::Offset<UpdatePlayerS2C> CreateUpdatePlayerS2C(::flatbuffers::FlatBufferBuilder &_fbb, const UpdatePlayerS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TeleportPlayerS2CT : public ::flatbuffers::NativeTable {
  typedef TeleportPlayerS2C TableType;
  uint64_t time = 0;
  std::unique_ptr<Protocol::Player> player{};
  TeleportPlayerS2CT() = default;
  TeleportPlayerS2CT(const TeleportPlayerS2CT &o);
  TeleportPlayerS2CT(TeleportPlayerS2CT&&) FLATBUFFERS_NOEXCEPT = default;
  TeleportPlayerS2CT &operator=(TeleportPlayerS2CT o) FLATBUFFERS_NOEXCEPT;
};

struct TeleportPlayerS2C FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TeleportPlayerS2CT NativeTableType;
  typedef TeleportPlayerS2CBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_PLAYER = 6
  };
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time = 0) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  const Protocol::Player *player() const {
    return GetStruct<const Protocol::Player *>(VT_PLAYER);
  }
  Protocol::Player *mutable_player() {
    return GetStruct<Protocol::Player *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME, 8) &&
           VerifyField<Protocol::Player>(verifier, VT_PLAYER, 4) &&
           verifier.EndTable();
  }
  TeleportPlayerS2CT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TeleportPlayerS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TeleportPlayerS2C> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TeleportPlayerS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TeleportPlayerS2CBuilder {
  typedef TeleportPlayerS2C Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(TeleportPlayerS2C::VT_TIME, time, 0);
  }
  void add_player(const Protocol::Player *player) {
    fbb_.AddStruct(TeleportPlayerS2C::VT_PLAYER, player);
  }
  explicit TeleportPlayerS2CBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TeleportPlayerS2C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TeleportPlayerS2C>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TeleportPlayerS2C> CreateTeleportPlayerS2C(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time = 0,
    const Protocol::Player *player = nullptr) {
  TeleportPlayerS2CBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_player(player);
  return builder_.Finish();
}

::flatbuffers::Offset<TeleportPlayerS2C> CreateTeleportPlayerS2C(::flatbuffers::FlatBufferBuilder &_fbb, const TeleportPlayerS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpawnLaserS2CT : public ::flatbuffers::NativeTable {
  typedef SpawnLaserS2C TableType;
  std::unique_ptr<Protocol::Laser> laser{};
  SpawnLaserS2CT() = default;
  SpawnLaserS2CT(const SpawnLaserS2CT &o);
  SpawnLaserS2CT(SpawnLaserS2CT&&) FLATBUFFERS_NOEXCEPT = default;
  SpawnLaserS2CT &operator=(SpawnLaserS2CT o) FLATBUFFERS_NOEXCEPT;
};

struct SpawnLaserS2C FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpawnLaserS2CT NativeTableType;
  typedef SpawnLaserS2CBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LASER = 4
  };
  const Protocol::Laser *laser() const {
    return GetStruct<const Protocol::Laser *>(VT_LASER);
  }
  Protocol::Laser *mutable_laser() {
    return GetStruct<Protocol::Laser *>(VT_LASER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Protocol::Laser>(verifier, VT_LASER, 8) &&
           verifier.EndTable();
  }
  SpawnLaserS2CT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpawnLaserS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SpawnLaserS2C> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpawnLaserS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpawnLaserS2CBuilder {
  typedef SpawnLaserS2C Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_laser(const Protocol::Laser *laser) {
    fbb_.AddStruct(SpawnLaserS2C::VT_LASER, laser);
  }
  explicit SpawnLaserS2CBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpawnLaserS2C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpawnLaserS2C>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpawnLaserS2C> CreateSpawnLaserS2C(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Protocol::Laser *laser = nullptr) {
  SpawnLaserS2CBuilder builder_(_fbb);
  builder_.add_laser(laser);
  return builder_.Finish();
}

::flatbuffers::Offset<SpawnLaserS2C> CreateSpawnLaserS2C(::flatbuffers::FlatBufferBuilder &_fbb, const SpawnLaserS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DespawnLaserS2CT : public ::flatbuffers::NativeTable {
  typedef DespawnLaserS2C TableType;
  uint32_t uuid = 0;
};

struct DespawnLaserS2C FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DespawnLaserS2CT NativeTableType;
  typedef DespawnLaserS2CBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4
  };
  uint32_t uuid() const {
    return GetField<uint32_t>(VT_UUID, 0);
  }
  bool mutate_uuid(uint32_t _uuid = 0) {
    return SetField<uint32_t>(VT_UUID, _uuid, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UUID, 4) &&
           verifier.EndTable();
  }
  DespawnLaserS2CT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DespawnLaserS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DespawnLaserS2C> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DespawnLaserS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DespawnLaserS2CBuilder {
  typedef DespawnLaserS2C Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uuid(uint32_t uuid) {
    fbb_.AddElement<uint32_t>(DespawnLaserS2C::VT_UUID, uuid, 0);
  }
  explicit DespawnLaserS2CBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DespawnLaserS2C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DespawnLaserS2C>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DespawnLaserS2C> CreateDespawnLaserS2C(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t uuid = 0) {
  DespawnLaserS2CBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

::flatbuffers::Offset<DespawnLaserS2C> CreateDespawnLaserS2C(::flatbuffers::FlatBufferBuilder &_fbb, const DespawnLaserS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CollisionS2CT : public ::flatbuffers::NativeTable {
  typedef CollisionS2C TableType;
  uint32_t uuid_first = 0;
  uint32_t uuid_second = 0;
};

struct CollisionS2C FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CollisionS2CT NativeTableType;
  typedef CollisionS2CBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID_FIRST = 4,
    VT_UUID_SECOND = 6
  };
  uint32_t uuid_first() const {
    return GetField<uint32_t>(VT_UUID_FIRST, 0);
  }
  bool mutate_uuid_first(uint32_t _uuid_first = 0) {
    return SetField<uint32_t>(VT_UUID_FIRST, _uuid_first, 0);
  }
  uint32_t uuid_second() const {
    return GetField<uint32_t>(VT_UUID_SECOND, 0);
  }
  bool mutate_uuid_second(uint32_t _uuid_second = 0) {
    return SetField<uint32_t>(VT_UUID_SECOND, _uuid_second, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UUID_FIRST, 4) &&
           VerifyField<uint32_t>(verifier, VT_UUID_SECOND, 4) &&
           verifier.EndTable();
  }
  CollisionS2CT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CollisionS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CollisionS2C> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CollisionS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CollisionS2CBuilder {
  typedef CollisionS2C Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uuid_first(uint32_t uuid_first) {
    fbb_.AddElement<uint32_t>(CollisionS2C::VT_UUID_FIRST, uuid_first, 0);
  }
  void add_uuid_second(uint32_t uuid_second) {
    fbb_.AddElement<uint32_t>(CollisionS2C::VT_UUID_SECOND, uuid_second, 0);
  }
  explicit CollisionS2CBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CollisionS2C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CollisionS2C>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CollisionS2C> CreateCollisionS2C(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t uuid_first = 0,
    uint32_t uuid_second = 0) {
  CollisionS2CBuilder builder_(_fbb);
  builder_.add_uuid_second(uuid_second);
  builder_.add_uuid_first(uuid_first);
  return builder_.Finish();
}

::flatbuffers::Offset<CollisionS2C> CreateCollisionS2C(::flatbuffers::FlatBufferBuilder &_fbb, const CollisionS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TextS2CT : public ::flatbuffers::NativeTable {
  typedef TextS2C TableType;
  std::string text{};
};

struct TextS2C FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextS2CT NativeTableType;
  typedef TextS2CBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  ::flatbuffers::String *mutable_text() {
    return GetPointer<::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
  TextS2CT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TextS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TextS2C> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TextS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TextS2CBuilder {
  typedef TextS2C Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(TextS2C::VT_TEXT, text);
  }
  explicit TextS2CBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextS2C> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextS2C>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextS2C> CreateTextS2C(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  TextS2CBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextS2C> CreateTextS2CDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return Protocol::CreateTextS2C(
      _fbb,
      text__);
}

::flatbuffers::Offset<TextS2C> CreateTextS2C(::flatbuffers::FlatBufferBuilder &_fbb, const TextS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputC2ST : public ::flatbuffers::NativeTable {
  typedef InputC2S TableType;
  uint64_t time = 0;
  uint16_t bitmap = 0;
};

struct InputC2S FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InputC2ST NativeTableType;
  typedef InputC2SBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_BITMAP = 6
  };
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time = 0) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  uint16_t bitmap() const {
    return GetField<uint16_t>(VT_BITMAP, 0);
  }
  bool mutate_bitmap(uint16_t _bitmap = 0) {
    return SetField<uint16_t>(VT_BITMAP, _bitmap, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME, 8) &&
           VerifyField<uint16_t>(verifier, VT_BITMAP, 2) &&
           verifier.EndTable();
  }
  InputC2ST *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputC2ST *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<InputC2S> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InputC2ST* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputC2SBuilder {
  typedef InputC2S Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(InputC2S::VT_TIME, time, 0);
  }
  void add_bitmap(uint16_t bitmap) {
    fbb_.AddElement<uint16_t>(InputC2S::VT_BITMAP, bitmap, 0);
  }
  explicit InputC2SBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InputC2S> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InputC2S>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InputC2S> CreateInputC2S(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time = 0,
    uint16_t bitmap = 0) {
  InputC2SBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_bitmap(bitmap);
  return builder_.Finish();
}

::flatbuffers::Offset<InputC2S> CreateInputC2S(::flatbuffers::FlatBufferBuilder &_fbb, const InputC2ST *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TextC2ST : public ::flatbuffers::NativeTable {
  typedef TextC2S TableType;
  std::string text{};
};

struct TextC2S FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextC2ST NativeTableType;
  typedef TextC2SBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  ::flatbuffers::String *mutable_text() {
    return GetPointer<::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
  TextC2ST *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TextC2ST *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TextC2S> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TextC2ST* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TextC2SBuilder {
  typedef TextC2S Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(TextC2S::VT_TEXT, text);
  }
  explicit TextC2SBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextC2S> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextC2S>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextC2S> CreateTextC2S(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  TextC2SBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextC2S> CreateTextC2SDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return Protocol::CreateTextC2S(
      _fbb,
      text__);
}

::flatbuffers::Offset<TextC2S> CreateTextC2S(::flatbuffers::FlatBufferBuilder &_fbb, const TextC2ST *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PacketWrapperT *PacketWrapper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PacketWrapperT>(new PacketWrapperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PacketWrapper::UnPackTo(PacketWrapperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = packet_type(); _o->packet.type = _e; }
  { auto _e = packet(); if (_e) _o->packet.value = Protocol::PacketTypeUnion::UnPack(_e, packet_type(), _resolver); }
}

inline ::flatbuffers::Offset<PacketWrapper> PacketWrapper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PacketWrapperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePacketWrapper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PacketWrapper> CreatePacketWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const PacketWrapperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PacketWrapperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _packet_type = _o->packet.type;
  auto _packet = _o->packet.Pack(_fbb);
  return Protocol::CreatePacketWrapper(
      _fbb,
      _packet_type,
      _packet);
}

inline ClientConnectS2CT *ClientConnectS2C::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ClientConnectS2CT>(new ClientConnectS2CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ClientConnectS2C::UnPackTo(ClientConnectS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); _o->uuid = _e; }
  { auto _e = time(); _o->time = _e; }
}

inline ::flatbuffers::Offset<ClientConnectS2C> ClientConnectS2C::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ClientConnectS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClientConnectS2C(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ClientConnectS2C> CreateClientConnectS2C(::flatbuffers::FlatBufferBuilder &_fbb, const ClientConnectS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ClientConnectS2CT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uuid = _o->uuid;
  auto _time = _o->time;
  return Protocol::CreateClientConnectS2C(
      _fbb,
      _uuid,
      _time);
}

inline GameStateS2CT *GameStateS2C::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GameStateS2CT>(new GameStateS2CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GameStateS2C::UnPackTo(GameStateS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = players(); if (_e) { _o->players.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->players[_i] = *_e->Get(_i); } } else { _o->players.resize(0); } }
  { auto _e = lasers(); if (_e) { _o->lasers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lasers[_i] = *_e->Get(_i); } } else { _o->lasers.resize(0); } }
}

inline ::flatbuffers::Offset<GameStateS2C> GameStateS2C::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GameStateS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGameStateS2C(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GameStateS2C> CreateGameStateS2C(::flatbuffers::FlatBufferBuilder &_fbb, const GameStateS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GameStateS2CT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _players = _o->players.size() ? _fbb.CreateVectorOfStructs(_o->players) : 0;
  auto _lasers = _o->lasers.size() ? _fbb.CreateVectorOfStructs(_o->lasers) : 0;
  return Protocol::CreateGameStateS2C(
      _fbb,
      _players,
      _lasers);
}

inline SpawnPlayerS2CT::SpawnPlayerS2CT(const SpawnPlayerS2CT &o)
      : player((o.player) ? new Protocol::Player(*o.player) : nullptr) {
}

inline SpawnPlayerS2CT &SpawnPlayerS2CT::operator=(SpawnPlayerS2CT o) FLATBUFFERS_NOEXCEPT {
  std::swap(player, o.player);
  return *this;
}

inline SpawnPlayerS2CT *SpawnPlayerS2C::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpawnPlayerS2CT>(new SpawnPlayerS2CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpawnPlayerS2C::UnPackTo(SpawnPlayerS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player(); if (_e) _o->player = std::unique_ptr<Protocol::Player>(new Protocol::Player(*_e)); }
}

inline ::flatbuffers::Offset<SpawnPlayerS2C> SpawnPlayerS2C::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpawnPlayerS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpawnPlayerS2C(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SpawnPlayerS2C> CreateSpawnPlayerS2C(::flatbuffers::FlatBufferBuilder &_fbb, const SpawnPlayerS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SpawnPlayerS2CT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player = _o->player ? _o->player.get() : nullptr;
  return Protocol::CreateSpawnPlayerS2C(
      _fbb,
      _player);
}

inline DespawnPlayerS2CT *DespawnPlayerS2C::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DespawnPlayerS2CT>(new DespawnPlayerS2CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DespawnPlayerS2C::UnPackTo(DespawnPlayerS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); _o->uuid = _e; }
}

inline ::flatbuffers::Offset<DespawnPlayerS2C> DespawnPlayerS2C::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DespawnPlayerS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDespawnPlayerS2C(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DespawnPlayerS2C> CreateDespawnPlayerS2C(::flatbuffers::FlatBufferBuilder &_fbb, const DespawnPlayerS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DespawnPlayerS2CT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uuid = _o->uuid;
  return Protocol::CreateDespawnPlayerS2C(
      _fbb,
      _uuid);
}

inline UpdatePlayerS2CT::UpdatePlayerS2CT(const UpdatePlayerS2CT &o)
      : time(o.time),
        player((o.player) ? new Protocol::Player(*o.player) : nullptr) {
}

inline UpdatePlayerS2CT &UpdatePlayerS2CT::operator=(UpdatePlayerS2CT o) FLATBUFFERS_NOEXCEPT {
  std::swap(time, o.time);
  std::swap(player, o.player);
  return *this;
}

inline UpdatePlayerS2CT *UpdatePlayerS2C::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UpdatePlayerS2CT>(new UpdatePlayerS2CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UpdatePlayerS2C::UnPackTo(UpdatePlayerS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time(); _o->time = _e; }
  { auto _e = player(); if (_e) _o->player = std::unique_ptr<Protocol::Player>(new Protocol::Player(*_e)); }
}

inline ::flatbuffers::Offset<UpdatePlayerS2C> UpdatePlayerS2C::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UpdatePlayerS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUpdatePlayerS2C(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UpdatePlayerS2C> CreateUpdatePlayerS2C(::flatbuffers::FlatBufferBuilder &_fbb, const UpdatePlayerS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UpdatePlayerS2CT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time = _o->time;
  auto _player = _o->player ? _o->player.get() : nullptr;
  return Protocol::CreateUpdatePlayerS2C(
      _fbb,
      _time,
      _player);
}

inline TeleportPlayerS2CT::TeleportPlayerS2CT(const TeleportPlayerS2CT &o)
      : time(o.time),
        player((o.player) ? new Protocol::Player(*o.player) : nullptr) {
}

inline TeleportPlayerS2CT &TeleportPlayerS2CT::operator=(TeleportPlayerS2CT o) FLATBUFFERS_NOEXCEPT {
  std::swap(time, o.time);
  std::swap(player, o.player);
  return *this;
}

inline TeleportPlayerS2CT *TeleportPlayerS2C::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TeleportPlayerS2CT>(new TeleportPlayerS2CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TeleportPlayerS2C::UnPackTo(TeleportPlayerS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time(); _o->time = _e; }
  { auto _e = player(); if (_e) _o->player = std::unique_ptr<Protocol::Player>(new Protocol::Player(*_e)); }
}

inline ::flatbuffers::Offset<TeleportPlayerS2C> TeleportPlayerS2C::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TeleportPlayerS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTeleportPlayerS2C(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TeleportPlayerS2C> CreateTeleportPlayerS2C(::flatbuffers::FlatBufferBuilder &_fbb, const TeleportPlayerS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TeleportPlayerS2CT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time = _o->time;
  auto _player = _o->player ? _o->player.get() : nullptr;
  return Protocol::CreateTeleportPlayerS2C(
      _fbb,
      _time,
      _player);
}

inline SpawnLaserS2CT::SpawnLaserS2CT(const SpawnLaserS2CT &o)
      : laser((o.laser) ? new Protocol::Laser(*o.laser) : nullptr) {
}

inline SpawnLaserS2CT &SpawnLaserS2CT::operator=(SpawnLaserS2CT o) FLATBUFFERS_NOEXCEPT {
  std::swap(laser, o.laser);
  return *this;
}

inline SpawnLaserS2CT *SpawnLaserS2C::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpawnLaserS2CT>(new SpawnLaserS2CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpawnLaserS2C::UnPackTo(SpawnLaserS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = laser(); if (_e) _o->laser = std::unique_ptr<Protocol::Laser>(new Protocol::Laser(*_e)); }
}

inline ::flatbuffers::Offset<SpawnLaserS2C> SpawnLaserS2C::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpawnLaserS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpawnLaserS2C(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SpawnLaserS2C> CreateSpawnLaserS2C(::flatbuffers::FlatBufferBuilder &_fbb, const SpawnLaserS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SpawnLaserS2CT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _laser = _o->laser ? _o->laser.get() : nullptr;
  return Protocol::CreateSpawnLaserS2C(
      _fbb,
      _laser);
}

inline DespawnLaserS2CT *DespawnLaserS2C::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DespawnLaserS2CT>(new DespawnLaserS2CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DespawnLaserS2C::UnPackTo(DespawnLaserS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); _o->uuid = _e; }
}

inline ::flatbuffers::Offset<DespawnLaserS2C> DespawnLaserS2C::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DespawnLaserS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDespawnLaserS2C(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DespawnLaserS2C> CreateDespawnLaserS2C(::flatbuffers::FlatBufferBuilder &_fbb, const DespawnLaserS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DespawnLaserS2CT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uuid = _o->uuid;
  return Protocol::CreateDespawnLaserS2C(
      _fbb,
      _uuid);
}

inline CollisionS2CT *CollisionS2C::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CollisionS2CT>(new CollisionS2CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CollisionS2C::UnPackTo(CollisionS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid_first(); _o->uuid_first = _e; }
  { auto _e = uuid_second(); _o->uuid_second = _e; }
}

inline ::flatbuffers::Offset<CollisionS2C> CollisionS2C::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CollisionS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCollisionS2C(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CollisionS2C> CreateCollisionS2C(::flatbuffers::FlatBufferBuilder &_fbb, const CollisionS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CollisionS2CT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uuid_first = _o->uuid_first;
  auto _uuid_second = _o->uuid_second;
  return Protocol::CreateCollisionS2C(
      _fbb,
      _uuid_first,
      _uuid_second);
}

inline TextS2CT *TextS2C::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TextS2CT>(new TextS2CT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TextS2C::UnPackTo(TextS2CT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); }
}

inline ::flatbuffers::Offset<TextS2C> TextS2C::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TextS2CT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTextS2C(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TextS2C> CreateTextS2C(::flatbuffers::FlatBufferBuilder &_fbb, const TextS2CT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TextS2CT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
  return Protocol::CreateTextS2C(
      _fbb,
      _text);
}

inline InputC2ST *InputC2S::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InputC2ST>(new InputC2ST());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InputC2S::UnPackTo(InputC2ST *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time(); _o->time = _e; }
  { auto _e = bitmap(); _o->bitmap = _e; }
}

inline ::flatbuffers::Offset<InputC2S> InputC2S::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InputC2ST* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInputC2S(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<InputC2S> CreateInputC2S(::flatbuffers::FlatBufferBuilder &_fbb, const InputC2ST *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InputC2ST* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time = _o->time;
  auto _bitmap = _o->bitmap;
  return Protocol::CreateInputC2S(
      _fbb,
      _time,
      _bitmap);
}

inline TextC2ST *TextC2S::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TextC2ST>(new TextC2ST());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TextC2S::UnPackTo(TextC2ST *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); }
}

inline ::flatbuffers::Offset<TextC2S> TextC2S::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TextC2ST* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTextC2S(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TextC2S> CreateTextC2S(::flatbuffers::FlatBufferBuilder &_fbb, const TextC2ST *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TextC2ST* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
  return Protocol::CreateTextC2S(
      _fbb,
      _text);
}

inline bool VerifyPacketType(::flatbuffers::Verifier &verifier, const void *obj, PacketType type) {
  switch (type) {
    case PacketType_NONE: {
      return true;
    }
    case PacketType_InputC2S: {
      auto ptr = reinterpret_cast<const Protocol::InputC2S *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_TextC2S: {
      auto ptr = reinterpret_cast<const Protocol::TextC2S *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_ClientConnectS2C: {
      auto ptr = reinterpret_cast<const Protocol::ClientConnectS2C *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_GameStateS2C: {
      auto ptr = reinterpret_cast<const Protocol::GameStateS2C *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_SpawnPlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::SpawnPlayerS2C *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_DespawnPlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::DespawnPlayerS2C *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_UpdatePlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::UpdatePlayerS2C *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_TeleportPlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::TeleportPlayerS2C *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_SpawnLaserS2C: {
      auto ptr = reinterpret_cast<const Protocol::SpawnLaserS2C *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_DespawnLaserS2C: {
      auto ptr = reinterpret_cast<const Protocol::DespawnLaserS2C *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_CollisionS2C: {
      auto ptr = reinterpret_cast<const Protocol::CollisionS2C *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_TextS2C: {
      auto ptr = reinterpret_cast<const Protocol::TextS2C *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPacketTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPacketType(
        verifier,  values->Get(i), types->GetEnum<PacketType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PacketTypeUnion::UnPack(const void *obj, PacketType type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case PacketType_InputC2S: {
      auto ptr = reinterpret_cast<const Protocol::InputC2S *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_TextC2S: {
      auto ptr = reinterpret_cast<const Protocol::TextC2S *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_ClientConnectS2C: {
      auto ptr = reinterpret_cast<const Protocol::ClientConnectS2C *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_GameStateS2C: {
      auto ptr = reinterpret_cast<const Protocol::GameStateS2C *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_SpawnPlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::SpawnPlayerS2C *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_DespawnPlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::DespawnPlayerS2C *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_UpdatePlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::UpdatePlayerS2C *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_TeleportPlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::TeleportPlayerS2C *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_SpawnLaserS2C: {
      auto ptr = reinterpret_cast<const Protocol::SpawnLaserS2C *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_DespawnLaserS2C: {
      auto ptr = reinterpret_cast<const Protocol::DespawnLaserS2C *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_CollisionS2C: {
      auto ptr = reinterpret_cast<const Protocol::CollisionS2C *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketType_TextS2C: {
      auto ptr = reinterpret_cast<const Protocol::TextS2C *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> PacketTypeUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case PacketType_InputC2S: {
      auto ptr = reinterpret_cast<const Protocol::InputC2ST *>(value);
      return CreateInputC2S(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_TextC2S: {
      auto ptr = reinterpret_cast<const Protocol::TextC2ST *>(value);
      return CreateTextC2S(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_ClientConnectS2C: {
      auto ptr = reinterpret_cast<const Protocol::ClientConnectS2CT *>(value);
      return CreateClientConnectS2C(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_GameStateS2C: {
      auto ptr = reinterpret_cast<const Protocol::GameStateS2CT *>(value);
      return CreateGameStateS2C(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_SpawnPlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::SpawnPlayerS2CT *>(value);
      return CreateSpawnPlayerS2C(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_DespawnPlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::DespawnPlayerS2CT *>(value);
      return CreateDespawnPlayerS2C(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_UpdatePlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::UpdatePlayerS2CT *>(value);
      return CreateUpdatePlayerS2C(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_TeleportPlayerS2C: {
      auto ptr = reinterpret_cast<const Protocol::TeleportPlayerS2CT *>(value);
      return CreateTeleportPlayerS2C(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_SpawnLaserS2C: {
      auto ptr = reinterpret_cast<const Protocol::SpawnLaserS2CT *>(value);
      return CreateSpawnLaserS2C(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_DespawnLaserS2C: {
      auto ptr = reinterpret_cast<const Protocol::DespawnLaserS2CT *>(value);
      return CreateDespawnLaserS2C(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_CollisionS2C: {
      auto ptr = reinterpret_cast<const Protocol::CollisionS2CT *>(value);
      return CreateCollisionS2C(_fbb, ptr, _rehasher).Union();
    }
    case PacketType_TextS2C: {
      auto ptr = reinterpret_cast<const Protocol::TextS2CT *>(value);
      return CreateTextS2C(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PacketTypeUnion::PacketTypeUnion(const PacketTypeUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case PacketType_InputC2S: {
      value = new Protocol::InputC2ST(*reinterpret_cast<Protocol::InputC2ST *>(u.value));
      break;
    }
    case PacketType_TextC2S: {
      value = new Protocol::TextC2ST(*reinterpret_cast<Protocol::TextC2ST *>(u.value));
      break;
    }
    case PacketType_ClientConnectS2C: {
      value = new Protocol::ClientConnectS2CT(*reinterpret_cast<Protocol::ClientConnectS2CT *>(u.value));
      break;
    }
    case PacketType_GameStateS2C: {
      value = new Protocol::GameStateS2CT(*reinterpret_cast<Protocol::GameStateS2CT *>(u.value));
      break;
    }
    case PacketType_SpawnPlayerS2C: {
      value = new Protocol::SpawnPlayerS2CT(*reinterpret_cast<Protocol::SpawnPlayerS2CT *>(u.value));
      break;
    }
    case PacketType_DespawnPlayerS2C: {
      value = new Protocol::DespawnPlayerS2CT(*reinterpret_cast<Protocol::DespawnPlayerS2CT *>(u.value));
      break;
    }
    case PacketType_UpdatePlayerS2C: {
      value = new Protocol::UpdatePlayerS2CT(*reinterpret_cast<Protocol::UpdatePlayerS2CT *>(u.value));
      break;
    }
    case PacketType_TeleportPlayerS2C: {
      value = new Protocol::TeleportPlayerS2CT(*reinterpret_cast<Protocol::TeleportPlayerS2CT *>(u.value));
      break;
    }
    case PacketType_SpawnLaserS2C: {
      value = new Protocol::SpawnLaserS2CT(*reinterpret_cast<Protocol::SpawnLaserS2CT *>(u.value));
      break;
    }
    case PacketType_DespawnLaserS2C: {
      value = new Protocol::DespawnLaserS2CT(*reinterpret_cast<Protocol::DespawnLaserS2CT *>(u.value));
      break;
    }
    case PacketType_CollisionS2C: {
      value = new Protocol::CollisionS2CT(*reinterpret_cast<Protocol::CollisionS2CT *>(u.value));
      break;
    }
    case PacketType_TextS2C: {
      value = new Protocol::TextS2CT(*reinterpret_cast<Protocol::TextS2CT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PacketTypeUnion::Reset() {
  switch (type) {
    case PacketType_InputC2S: {
      auto ptr = reinterpret_cast<Protocol::InputC2ST *>(value);
      delete ptr;
      break;
    }
    case PacketType_TextC2S: {
      auto ptr = reinterpret_cast<Protocol::TextC2ST *>(value);
      delete ptr;
      break;
    }
    case PacketType_ClientConnectS2C: {
      auto ptr = reinterpret_cast<Protocol::ClientConnectS2CT *>(value);
      delete ptr;
      break;
    }
    case PacketType_GameStateS2C: {
      auto ptr = reinterpret_cast<Protocol::GameStateS2CT *>(value);
      delete ptr;
      break;
    }
    case PacketType_SpawnPlayerS2C: {
      auto ptr = reinterpret_cast<Protocol::SpawnPlayerS2CT *>(value);
      delete ptr;
      break;
    }
    case PacketType_DespawnPlayerS2C: {
      auto ptr = reinterpret_cast<Protocol::DespawnPlayerS2CT *>(value);
      delete ptr;
      break;
    }
    case PacketType_UpdatePlayerS2C: {
      auto ptr = reinterpret_cast<Protocol::UpdatePlayerS2CT *>(value);
      delete ptr;
      break;
    }
    case PacketType_TeleportPlayerS2C: {
      auto ptr = reinterpret_cast<Protocol::TeleportPlayerS2CT *>(value);
      delete ptr;
      break;
    }
    case PacketType_SpawnLaserS2C: {
      auto ptr = reinterpret_cast<Protocol::SpawnLaserS2CT *>(value);
      delete ptr;
      break;
    }
    case PacketType_DespawnLaserS2C: {
      auto ptr = reinterpret_cast<Protocol::DespawnLaserS2CT *>(value);
      delete ptr;
      break;
    }
    case PacketType_CollisionS2C: {
      auto ptr = reinterpret_cast<Protocol::CollisionS2CT *>(value);
      delete ptr;
      break;
    }
    case PacketType_TextS2C: {
      auto ptr = reinterpret_cast<Protocol::TextS2CT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = PacketType_NONE;
}

inline const Protocol::PacketWrapper *GetPacketWrapper(const void *buf) {
  return ::flatbuffers::GetRoot<Protocol::PacketWrapper>(buf);
}

inline const Protocol::PacketWrapper *GetSizePrefixedPacketWrapper(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Protocol::PacketWrapper>(buf);
}

inline PacketWrapper *GetMutablePacketWrapper(void *buf) {
  return ::flatbuffers::GetMutableRoot<PacketWrapper>(buf);
}

inline Protocol::PacketWrapper *GetMutableSizePrefixedPacketWrapper(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Protocol::PacketWrapper>(buf);
}

inline bool VerifyPacketWrapperBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Protocol::PacketWrapper>(nullptr);
}

inline bool VerifySizePrefixedPacketWrapperBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Protocol::PacketWrapper>(nullptr);
}

inline void FinishPacketWrapperBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Protocol::PacketWrapper> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPacketWrapperBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Protocol::PacketWrapper> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Protocol::PacketWrapperT> UnPackPacketWrapper(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Protocol::PacketWrapperT>(GetPacketWrapper(buf)->UnPack(res));
}

inline std::unique_ptr<Protocol::PacketWrapperT> UnPackSizePrefixedPacketWrapper(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Protocol::PacketWrapperT>(GetSizePrefixedPacketWrapper(buf)->UnPack(res));
}

}  // namespace Protocol

#endif  // FLATBUFFERS_GENERATED_PROTO_PROTOCOL_H_
